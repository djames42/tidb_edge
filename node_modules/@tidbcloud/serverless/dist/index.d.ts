interface ServerlessError {
    message: string;
    code: string;
}
declare class DatabaseError extends Error {
    details: ServerlessError | null;
    status: number;
    constructor(message: string, status: number, details: ServerlessError | null);
}

type Req = {
    method: string;
    headers: Record<string, string>;
    body: string;
    cache?: RequestCache;
};
type Res = {
    ok: boolean;
    status: number;
    statusText: string;
    headers: any;
    json(): Promise<any>;
    text(): Promise<string>;
};
interface Config {
    url?: string;
    username?: string;
    password?: string;
    database?: string;
    host?: string;
    fetch?: (input: string, init?: Req) => Promise<Res>;
    arrayMode?: boolean;
    fullResult?: boolean;
}
interface ExecuteOptions {
    arrayMode?: boolean;
    fullResult?: boolean;
}
interface TxOptions {
    isolation?: 'READ COMMITTED' | 'REPEATABLE READ';
}
type ExecuteArgs = object | any[] | null;

type Row = Record<string, any> | any[];
type Types = Record<string, string>;
interface FullResult {
    types: Types | null;
    rows: Row[] | null;
    statement: string;
    rowCount: number | null;
    rowsAffected: number | null;
    lastInsertId: number | null;
}
interface Field {
    name: string;
    type: string;
    nullable: boolean;
}
declare class Tx {
    private conn;
    constructor(conn: Connection);
    execute(query: string, args?: ExecuteArgs, options?: ExecuteOptions, txOptions?: TxOptions): Promise<FullResult | Row[]>;
    commit(): Promise<FullResult | Row[]>;
    rollback(): Promise<FullResult | Row[]>;
}
declare class Connection {
    private config;
    private session;
    constructor(config: Config);
    begin(txOptions?: TxOptions): Promise<Tx>;
    execute(query: string, args?: ExecuteArgs, options?: ExecuteOptions, txOptions?: TxOptions): Promise<FullResult | Row[]>;
}
declare function connect(config: Config): Connection;

export { Config, Connection, DatabaseError, ExecuteArgs, ExecuteOptions, Field, FullResult, Row, Tx, Types, connect };
